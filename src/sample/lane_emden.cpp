#include <cmath>
#include <vector>
#include <fstream>
#include <sstream>
#include <string>

#include "solver.hpp"
#include "simulation.hpp"
#include "particle.hpp"
#include "exception.hpp"
#include "parameters.hpp"

namespace sph
{

// Lane-Emden n=3/2 (gamma=5/3) hydrostatic equilibrium sphere
// Reads EXACT solution from Python-generated data file

void Solver::make_lane_emden()
{
#if DIM != 3
    THROW_ERROR("Lane-Emden test requires DIM == 3");
#else

    const int N = boost::any_cast<int>(m_sample_parameters["N"]);
    std::cout << "Creating Lane-Emden n=3/2 hydrostatic sphere with N = " << N << std::endl;
    
    auto & p = m_sim->get_particles();
    const real dx = 2.0 / N;
    const real gamma = m_param->physics.gamma;
    const real G = m_param->gravity.constant;
    
    // Physical parameters
    const real R = 1.0;          // Sphere radius
    const real M_total = 1.0;    // Total mass
    
    // ========================================================================
    // READ LANE-EMDEN SOLUTION FROM FILE
    // Generated by scripts/preprocessing/generate_lane_emden.py
    // ========================================================================
    
    std::string filename = "data/lane_emden/n1.5_3d.dat";
    std::ifstream infile(filename);
    
    if(!infile.is_open()) {
        THROW_ERROR("Cannot open Lane-Emden solution file: " + filename);
    }
    
    real xi_1, dtheta_1;
    int n_points_file;
    std::vector<real> xi_array, theta_array;
    
    std::string line;
    while(std::getline(infile, line)) {
        // Skip comments and parse header
        if(line[0] == '#') {
            if(line.find("xi_1") != std::string::npos) {
                sscanf(line.c_str(), "# xi_1 = %lf", &xi_1);
            } else if(line.find("dtheta_1") != std::string::npos) {
                sscanf(line.c_str(), "# dtheta_1 = %lf", &dtheta_1);
            } else if(line.find("n_points") != std::string::npos) {
                sscanf(line.c_str(), "# n_points = %d", &n_points_file);
            }
            continue;
        }
        
        // Parse data: xi theta dtheta
        real xi, theta, dtheta;
        std::istringstream iss(line);
        if(iss >> xi >> theta >> dtheta) {
            xi_array.push_back(xi);
            theta_array.push_back(theta);
        }
    }
    infile.close();
    
    if(xi_array.empty()) {
        THROW_ERROR("Failed to read Lane-Emden solution data");
    }
    
    std::cout << "Lane-Emden: Loaded solution from " << filename << std::endl;
    std::cout << "Lane-Emden: ξ₁ = " << xi_1 << ", |dθ/dξ|_{ξ₁} = " << std::abs(dtheta_1) << std::endl;
    std::cout << "Lane-Emden: Data points: " << xi_array.size() << std::endl;
    
    // ========================================================================
    // SETUP PHYSICAL PARAMETERS
    // ========================================================================
    
    // Scaling: r = α*ξ where we want r(ξ₁) = R, so α = R/ξ₁
    const real alpha = R / xi_1;
    
    // From Lane-Emden: M = 4π α³ ρ_c ξ₁² |dθ/dξ|_{ξ₁}
    const real rho_center = M_total / (4.0 * M_PI * alpha * alpha * alpha * xi_1 * xi_1 * std::abs(dtheta_1));
    
    // Polytropic constant: K = 4πG α² ρ_c^(1/3) / (5/2) for n=3/2
    const real K = 4.0 * M_PI * G * alpha * alpha * std::pow(rho_center, 1.0/3.0) / 2.5;
    
    std::cout << "Lane-Emden: M = " << M_total << ", R = " << R << std::endl;
    std::cout << "Lane-Emden: α = " << alpha << ", ρ_center = " << rho_center << std::endl;
    std::cout << "Lane-Emden: K = " << K << ", G = " << G << ", gamma = " << gamma << std::endl;
    
    // ========================================================================
    // CREATE EQUAL-MASS PARTICLES WITH LANE-EMDEN DENSITY PROFILE
    // Uses spherical shell distribution to avoid neighbor overflow
    // ========================================================================
    
    // Interpolation function for θ(ξ) using loaded data
    auto get_theta = [&](real xi_val) -> real {
        if(xi_val >= xi_1) return 0.0;
        if(xi_val <= 0.0) return 1.0;
        
        // Linear search for bracket
        int idx = 0;
        for(size_t i = 0; i < xi_array.size() - 1; ++i) {
            if(xi_val >= xi_array[i] && xi_val < xi_array[i+1]) {
                idx = i;
                break;
            }
        }
        
        // Linear interpolation
        const real frac = (xi_val - xi_array[idx]) / (xi_array[idx+1] - xi_array[idx]);
        return theta_array[idx] * (1.0 - frac) + theta_array[idx+1] * frac;
    };
    
    // Build cumulative mass profile M(r) for equal-mass particle placement
    // M(r) = 4π α³ ρ_c ∫₀^ξ ξ² θ^n dξ where ξ = r/α
    std::vector<real> mass_profile(xi_array.size());
    mass_profile[0] = 0.0;
    
    for(size_t i = 1; i < xi_array.size(); ++i) {
        const real dxi = xi_array[i] - xi_array[i-1];
        const real xi_mid = 0.5 * (xi_array[i] + xi_array[i-1]);
        const real theta_mid = 0.5 * (theta_array[i] + theta_array[i-1]);
        const real rho_mid = std::pow(theta_mid, 1.5);  // ρ/ρ_c = θ^1.5
        
        // dM = 4π α³ ρ_c × ξ² θ^1.5 dξ
        const real dM = 4.0 * M_PI * pow3(alpha) * rho_center * xi_mid * xi_mid * rho_mid * dxi;
        mass_profile[i] = mass_profile[i-1] + dM;
    }
    
    // Normalize mass profile to M_total
    const real M_computed = mass_profile.back();
    for(auto & m : mass_profile) {
        m *= M_total / M_computed;
    }
    
    std::cout << "Lane-Emden: Mass profile computed, M_check = " << M_computed << std::endl;
    
    // Determine number of particles and mass per particle
    const int N_particles = N * N * N / 5;  // Roughly N³/5 particles for reasonable coverage
    const real particle_mass = M_total / N_particles;
    
    std::cout << "Lane-Emden: Target particle count = " << N_particles << std::endl;
    std::cout << "Lane-Emden: Particle mass = " << particle_mass << std::endl;
    
    // Generate particles in spherical shells with equal mass spacing
    int count_added = 0;
    
    for(int ip = 0; ip < N_particles; ++ip) {
        // Target enclosed mass for this particle
        const real m_target = (ip + 0.5) * particle_mass;
        
        // Find radius r such that M(r) = m_target
        // Binary search in mass_profile
        real r_shell = 0.0;
        for(size_t i = 1; i < mass_profile.size(); ++i) {
            if(m_target >= mass_profile[i-1] && m_target < mass_profile[i]) {
                const real frac = (m_target - mass_profile[i-1]) / (mass_profile[i] - mass_profile[i-1]);
                const real xi_interp = xi_array[i-1] + frac * (xi_array[i] - xi_array[i-1]);
                r_shell = xi_interp * alpha;
                break;
            }
        }
        
        if(r_shell <= 0.0 || r_shell >= R) {
            continue;  // Skip invalid radii
        }
        
        // Place particle at radius r_shell with uniform angular distribution
        // Use Fibonacci sphere algorithm for even distribution on sphere surface
        const real phi = M_PI * (1.0 + std::sqrt(5.0));  // Golden angle ≈ 2.4
        const real theta_angle = phi * real(count_added);  // Azimuthal angle
        // z ranges from -1 to +1 linearly
        const real z = 1.0 - 2.0 * (real(count_added) + 0.5) / real(N_particles);
        const real radius_xy = std::sqrt(1.0 - z * z);  // Radius in xy-plane
        
        vec_t pos = {
            r_shell * radius_xy * std::cos(theta_angle),
            r_shell * radius_xy * std::sin(theta_angle),
            r_shell * z
        };
        
        const real r = std::abs(pos);
        
        // Get Lane-Emden solution at this radius
        const real xi = r / alpha;
        const real theta = get_theta(xi);
        
        if(theta <= 0.0) {
            continue;
        }
        
        // Density from Lane-Emden: ρ(r) = ρ_c * θ^(3/2)
        const real dens = rho_center * std::pow(theta, 1.5);
        
        if(dens <= 1e-10) {
            continue;
        }
        
        // Pressure from polytropic relation: P = K * ρ^γ
        const real pres = K * std::pow(dens, gamma);
        
        // Internal energy: u = P / ((γ-1) * ρ)
        const real ene = pres / ((gamma - 1.0) * dens);
        
        SPHParticle p_i;
        p_i.pos = pos;
        p_i.vel = 0.0;  // Initially at rest (hydrostatic equilibrium)
        p_i.dens = dens;
        p_i.pres = pres;
        p_i.ene = ene;
        p_i.mass = particle_mass;
        p_i.id = count_added;
        
        p.emplace_back(p_i);
        count_added++;
    }
    
    std::cout << "Lane-Emden: Created " << p.size() << " equal-mass particles" << std::endl;
    std::cout << "Lane-Emden: Particle mass = " << particle_mass << std::endl;
    std::cout << "Lane-Emden: Using EXACT Lane-Emden n=3/2 density profile from data file" << std::endl;
    std::cout << "Lane-Emden: Equal-mass placement avoids neighbor overflow" << std::endl;
    std::cout << "Lane-Emden: This sphere is in PERFECT hydrostatic equilibrium (analytically)" << std::endl;
    std::cout << "Lane-Emden: Monitor radius and energy - should remain nearly constant" << std::endl;
    
    // Store parameters for relaxation module
    m_sample_parameters["alpha"] = alpha;
    m_sample_parameters["rho_center"] = rho_center;
    m_sample_parameters["K"] = K;
    m_sample_parameters["R"] = R;
    m_sample_parameters["M_total"] = M_total;
    
    m_sim->set_particles(p);
    m_sim->set_particle_num(p.size());
#endif
}

}
